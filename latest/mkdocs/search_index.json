{
    "docs": [
        {
            "location": "/", 
            "text": "ExtractMacro.jl documentation\n\n\nThis module provides the \n@extract\n macro:\n\n\n#\n\n\nExtractMacro.@extract\n \n \nMacro\n.\n\n\n@extract obj : exprs...\n\n\n\n\nExtracts fields from composite types. E.g.\n\n\n@extract x : a b\n\n# is translated to:\n\na = x.a\nb = x.b\n\n\n\n\nThe colon is optional: \n@extract x a b\n is the same as above. Destination variable names can be changed, and arbitrary functions (including indexing) applied, e.g.:\n\n\n@extract x : q=b a1=abs(a[1]) ai=abs(a[i]) y=max(a[1],b)\n# is translated to:\nq = x.b\na1 = abs(x.a[1])\nai = abs(x.a[i])\ny = max(x.a[1], x.b)\n\n\n\n\nNotice that the \ni\n within the indexing expression is left untouched: indexing is special in this regard.\n\n\nIn order to explicitly avoid symbol manipulation on the right hand side, use \nesc()\n: this\n\n\n@extract x : y=abs(a[1] + esc(b))\n\n# is translated to:\n\ny = abs(x.a[1] + b)", 
            "title": "Home"
        }, 
        {
            "location": "/#extractmacrojl-documentation", 
            "text": "This module provides the  @extract  macro:  #  ExtractMacro.@extract     Macro .  @extract obj : exprs...  Extracts fields from composite types. E.g.  @extract x : a b\n\n# is translated to:\n\na = x.a\nb = x.b  The colon is optional:  @extract x a b  is the same as above. Destination variable names can be changed, and arbitrary functions (including indexing) applied, e.g.:  @extract x : q=b a1=abs(a[1]) ai=abs(a[i]) y=max(a[1],b)\n# is translated to:\nq = x.b\na1 = abs(x.a[1])\nai = abs(x.a[i])\ny = max(x.a[1], x.b)  Notice that the  i  within the indexing expression is left untouched: indexing is special in this regard.  In order to explicitly avoid symbol manipulation on the right hand side, use  esc() : this  @extract x : y=abs(a[1] + esc(b))\n\n# is translated to:\n\ny = abs(x.a[1] + b)", 
            "title": "ExtractMacro.jl documentation"
        }
    ]
}