{
    "docs": [
        {
            "location": "/", 
            "text": "ExtractMacro.jl documentation\n\n\nThis package provides just one macro, \n@extract\n, which you can use by entering:\n\n\nusing ExtractMacro\n\n\n\n\nThe macro creates local variables from expressions involving composite types fields. It is especially useful to avoid writing expressions of the form \nobj.field\n repeatedly. For example, instead of having code like this:\n\n\npotential(network::Network, i::Int) =\n    dot(unsafe(network.J[i]), unsafe(network.current_state.s)) - network.H0 -\n        network.lambda * (network.current_state.S - network.f * network.N)\n\n\n\n\nyou could use the macro and get a more readable version:\n\n\nfunction potential(network::Network, i::Int)\n    @extract network : N f H0 lambda state=current_state Ji=unsafe(J[i])\n    @extract state   : S s=unsafe(s)\n\n    return dot(Ji, s) - H0 - lambda * (S - f * N)\nend\n\n\n\n\nThis makes the function look a little bit like a method in some standard OO languages (e.g., C++) where class methods bring the class fields in scope. Note however that the \n@extract\n macro does not work like that: it always works by creating local variables. The consequences of this are discussed further after the macro documentation.\n\n\n#\n\n\nExtractMacro.@extract\n \n \nMacro\n.\n\n\n@extract obj : exprs...\n\n\n\n\nExtracts fields from composite types. E.g.\n\n\n@extract x : a b\n\n\n\n\nis translated to:\n\n\na = x.a\nb = x.b\n\n\n\n\nThe colon is optional: \n@extract x a b\n is the same as above. Destination variable names can be changed, and arbitrary functions (including indexing) applied, e.g.:\n\n\n@extract x : q=b a1=abs(a[1]) ai=abs(a[i]) y=max(a[1],b)\n\n\n\n\nis translated to:\n\n\nq = x.b\na1 = abs(x.a[1])\nai = abs(x.a[i])\ny = max(x.a[1], x.b)\n\n\n\n\nNotice that the \ni\n within the indexing expression is left untouched: indexing is special in this regard.\n\n\nIn order to explicitly avoid symbol manipulation on the right hand side, use \nesc()\n: this\n\n\n@extract x : y=abs(a[1] + esc(b))\n\n\n\n\nis translated to:\n\n\ny = abs(x.a[1] + b)\n\n\n\n\nAs mentioned above, since the assignments follow the usual Julia pass-by-reference rules, if you extract a scalar value (e.g. an \nInt\n) from a field, and subsequently modify it, the value of the field in the parent object will not be affected. But if you extract a container (e.g. a \nVector\n) and modify its contents, the change will be reflected in the parent object. For example:\n\n\ntype X\n    a::Int\n    v::Vector{Int}\nend\nx = X(1, [2,3,4])\n@extract x : a v\na = 5     # will not change x.a\nv[1] = 5  # will change x.v[1]", 
            "title": "Home"
        }, 
        {
            "location": "/#extractmacrojl-documentation", 
            "text": "This package provides just one macro,  @extract , which you can use by entering:  using ExtractMacro  The macro creates local variables from expressions involving composite types fields. It is especially useful to avoid writing expressions of the form  obj.field  repeatedly. For example, instead of having code like this:  potential(network::Network, i::Int) =\n    dot(unsafe(network.J[i]), unsafe(network.current_state.s)) - network.H0 -\n        network.lambda * (network.current_state.S - network.f * network.N)  you could use the macro and get a more readable version:  function potential(network::Network, i::Int)\n    @extract network : N f H0 lambda state=current_state Ji=unsafe(J[i])\n    @extract state   : S s=unsafe(s)\n\n    return dot(Ji, s) - H0 - lambda * (S - f * N)\nend  This makes the function look a little bit like a method in some standard OO languages (e.g., C++) where class methods bring the class fields in scope. Note however that the  @extract  macro does not work like that: it always works by creating local variables. The consequences of this are discussed further after the macro documentation.  #  ExtractMacro.@extract     Macro .  @extract obj : exprs...  Extracts fields from composite types. E.g.  @extract x : a b  is translated to:  a = x.a\nb = x.b  The colon is optional:  @extract x a b  is the same as above. Destination variable names can be changed, and arbitrary functions (including indexing) applied, e.g.:  @extract x : q=b a1=abs(a[1]) ai=abs(a[i]) y=max(a[1],b)  is translated to:  q = x.b\na1 = abs(x.a[1])\nai = abs(x.a[i])\ny = max(x.a[1], x.b)  Notice that the  i  within the indexing expression is left untouched: indexing is special in this regard.  In order to explicitly avoid symbol manipulation on the right hand side, use  esc() : this  @extract x : y=abs(a[1] + esc(b))  is translated to:  y = abs(x.a[1] + b)  As mentioned above, since the assignments follow the usual Julia pass-by-reference rules, if you extract a scalar value (e.g. an  Int ) from a field, and subsequently modify it, the value of the field in the parent object will not be affected. But if you extract a container (e.g. a  Vector ) and modify its contents, the change will be reflected in the parent object. For example:  type X\n    a::Int\n    v::Vector{Int}\nend\nx = X(1, [2,3,4])\n@extract x : a v\na = 5     # will not change x.a\nv[1] = 5  # will change x.v[1]", 
            "title": "ExtractMacro.jl documentation"
        }
    ]
}